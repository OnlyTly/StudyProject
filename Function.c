#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <math.h>
#include <string.h>
//函数默认返回的是int型，所以要明确自定义函数的返回类型
// main函数其实有3个参数（int argc,char* argv[],char*envp）
// 
//形参-形式参数
//void Swap(int x,int y)
//{
//	int z = 0;
//	z = x;
//	x = y;
//	y = z;
//}
//当实参传递给形参的时候，形参是实参的一份临时拷贝
//对形参的修改不能改变实参
//所以通过指针，传送地址来进行整型变量的互换
//何时不需要传送地址：传参时不会影响到实参本身或只是为了获得一个返回值

//void swap(int *px,int *py)
//{
//	int z = 0;
//	z = *px;
//	*px = *py;
//	*py = z;
//}
//int main()
//{
//	//实参-实际参数
//	int a = 0;
//	int b = 0;
//	scanf("%d%d", &a, &b);
//	printf("交换前：a=%d,b=%d\n", a, b);
//
//	//Swap(a, b);
//
//	swap(&a,&b);
//	printf("交换后：a=%d,b=%d\n", a, b);
//	return 0;
//}
//------------------------------------------------------------------------------
	


//判断某个范围内的素数
//int main()
//{
//	int i = 0;
//	for (i = 101; i <= 200; i+=2)
//	{
//		//判断i是否为素数，是则打印
//		//用2到i-1的数字去试除
//		int flag = 1;
//		for (int j = 2; j <= i-1/sqrt(i); j++)
//		{
//			//sqrt();数学库函数，表示开平方。使用前要引入头文件math.h
//			if (i % j ==0)
//			{
//				flag = 0;
//				break;
//			}
//		}
//		if (flag ==1 )
//		{
//			printf("%dt",i);
//		}
//	}
//	return 0;
//}
//----------------------------------------------------------------------------------
//写一个函数可以判断是不是素数
	//素数：只能被1和本身整除
//int is_prime(int n)
//{
//		for (int j = 2; j <= sqrt(n); j++)
//		{
//					
//			if (n % j ==0)
//			{
//				return 0;
//			}
//		}
//		return 1;
//}
//
//
//int main()
//{
//		int i = 0;
//		int count = 0;
//		for (i = 101; i <= 200; i+=2)
//		{
//
//			if (is_prime(i))
//			{
//				printf("%d\t", i);
//				count++;
//			}
//			
//		}
//	printf("\n共%d个素数", count);
//		return 0;
//
//}
//----------------------------------------------------------------------------------
//用函数输出范围内的闰年
//int is_Year( int x)
//{
//	if ((x % 4 == 0 && x % 100 != 0) || (x % 400 == 0))
//	{
//		return 1;
//	}
//	return 0;
//}
//
//int main()
//{
//	int count = 0;
//	for (int i = 1000; i < 2023; i++)
//	{
//		if (is_Year(i))
//		{
//			printf("%d年为闰年; ",i);
//			count++;
//		}
//	}
//	printf("\n共%d个润年", count);
//}
//----------------------------------------------------------------------------------
//用函数，实现二分查找
// //数组传参实际上传递的是数组首元素的地址，而不是整个数组
// //数组名作为参数传递函数时，退化为指针，形参的arr看上去是个数组，实际是个指针变量
//int binary_search(int arr[],int k,int length ) {
//	int left = 0;//左下标
//	int right = length - 1;//右下标
//
//	while (left <= right)//如果left大于right了，说明找不到要找的数
//	{
//		int mid = left + (right - left) / 2;//不断寻找中间值向两边查询
//
//		if (arr[mid] > k)
//		{
//			right = mid - 1;
//		}
//		else if (arr[mid] < k)
//		{
//			left = mid + 1;
//		}
//		else
//		{
//			return mid;//找到了
//		}
//	}
//	return -1;//找不到
//}
//
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int k = 10;
//	int length = sizeof(arr) / sizeof(arr[0]);
//	
//	//通过函数返回值，进行判断。
//	//找到了，返回下标
//	//找不到，返回-1，因为下标从0开始
//
//	int ret = binary_search(arr, k, length);
//	if (ret == -1)
//	{
//		printf("查无此数\n");
//	}
//	else
//	{
//		printf("找到它了，下标为：%d\n", ret);
//	}	
//		return 0;
//}
//------------------------------------------------------------------------------------------------------
//写一个函数，每调用一次，num的值+1
//void add(int* p)
//{
//	(*p)++;
//}
//int main()
//{
//	int num = 0;
//	add(&num);
//	printf("%d", num);
//	add(&num);
//	printf("%d", num);
//	add(&num);
//	printf("%d", num);
//	add(&num);
//	printf("%d", num);
//	add(&num);
//	printf("%d", num);
//}
//----------------------------------------------------------------------------------------------------------
//函数的声明和定义
// 
//因为计算机是从上往下顺序编译，若想在main函数中调用其下方的函数，则需要进行函数的声明
//函数的声明：告诉编译器这个函数叫什么，参数是什么，返回的数据类型是什么
//但是函数存不存在与声明无关，与定义相关
// 函数的声明一般放在头文件中
//int Add(int,int);
//---------------------------------------------------------
//#include "add.h"
//静态库的导入
//#pragma comment(lib,"库名")
//若是别人需要你的私密代码，你不想给，学着去用静态库

//int main()
//{
//	int a = 0;
//	int b = 0;
//	scanf("%d%d\n", &a, &b);
//	int sum =Add(a, b);
//	printf("%d\n", sum);
//	return 0;
//}
//函数的定义
//指函数的具体实现和交待函数的功能
//int Add(int x, int y)
//{
//	return x + y;
//}

//-----------------------------------------------------------------------------------------------------
	//递归函数
	//递归的两个必要条件
	//1.存在限制条件，当满足这个条件时，递归便不再继续
	//2.每次递归调用之后越来越接近这个限制条件

//例1：接受一个整型值（无符号），按照顺序打印它的每一位
//输入1234，打印1 2 3 4
//%d:打印有符号的整数
//&u:打印无符号的整数
// ---------------------------------------
//print(unsigned int n)
//{
//	if (n>9)
//	{
//		print(n/10);
//	}
//	printf("%d ", n % 10);
//}
//
//int main()
//{
//	unsigned int num = 0;
//	scanf("%u", &num);
//	print(num);
//	return 0;
//}

//----------------------------------------------------------
//例2
//编写函数不允许创建临时变量，求字符串的长度
// 
//1.使用临时变量，

//int my_strlen(char* str) {
//	int count = 0;
//	while (*str != '\0')
//	{
//		count++;
//		str++;//找下一个地址
//	}
//	return count;
//}
//str中传过来的是数组中首个字符的的地址，所以通过指针*str找到数组中的值
//---------------------------------------------
//2.使用递归函数

int my_strlen(char* str) {
	if (*str != '\0')
	{
		return 1 + my_strlen(str + 1);//str+1:也是指向下一个地址
	}
	return 0;
}
//思路
//因为第一个字符不是\0，所以可以确定长度1+？，对字符串进行拆分统计
//my_strlen("abc")				a!='\0' ,retuen 1 + mystrlen(b)
//1+my_strlen("bc")				b!='\0' ,retuen 1 + 1 + mystrlen(c)
//1+1+my_strlen("c")			c!='\0' ,retuen 1 + 1 + 1 + mystrlen(\0)
//1+1+1+my_strlen("\0")			\0='\0' ,retuen 1 + 1 + 1 + 0
//
int main()
{
	char arr[] = "abc"; //{a,b,c,\0}

	int length = my_strlen(arr);
	printf("%d",length);
	return 0;
}






