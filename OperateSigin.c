#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
//算术运算符、移位操作符
/*int main()
{
//--------------------------------------------------------------------------------
	//1.算术运算符
	// + - * / %
	//%和/的区分
	// %：模除，结果为余数。两端必须为整数
	// /：整除，结果为商
//--------------------------------------------------------------------------------
	//2.移位操作符，只用于整数
	//移动的是二进制位
	//整数的二进制有三种表示方法：原码、补码、反码
	// 规则：1.正整数的原码补码反码相同，正整数，三码合一。
	//		 2.二进制的最高位是符号位，0表示正数，1表示负数
	//		 3.负数的反码 = 它的原码符号位不变，其他位取反（0->1,1->0）
	//		 4.负数的补码 = 它的反码 + 1 ; 负数的反码 = 负数的补码 -1;
	//		 5.0的反码补码都是0
	//		 6.在计算机运算的时候，都是以补码的方式运算
	//		 7.我们得到运算结果的时候，要看它的原码
	//		 8.整数在内存中，存的是补码
	//左移 <<：向左移动n个二进制位，低位补0。本质：每向左移一位，相等于每一位二进制位数上的数乘2。即 移n位 = 原值*（n个）2
	//右移 >>：算数右移：向右移动n个二进制位，高位补原符号位（VS编译器采用，大多数也都采用）
	//         逻辑右移：向右移动n个二进制位，高位补0
	//		   右移取决与编译器的不同
	int a = 2;
	int b = a << 1;
	//整型4个字节，1个字节是8位，所以一个整型需要32位
	//eg：
	//1.写出2的原码：00000000 00000000 00000000 00000010
	//2.写出2的补码：00000000 00000000 00000000 00000010
	//3.向左移一位： 00000000 00000000 00000000 00000100
	//4.移动后的补码:00000000 00000000 00000000 00000100
	//5.移动后的原码:00000000 00000000 00000000 00000100
	//6.该二进制原码的值：4
	printf("%d\n", a);//a=2
	printf("%d\n", b);//b=4
	int c = -1;
	int d = c << 1;
	//1.写出-1的原码：10000000 00000000 00000000 00000001
	//2.写出-1的反码：11111111 11111111 11111111 11111110
	//3.写出-1的补码：11111111 11111111 11111111 11111111
	//4.向左移一位：  11111111 11111111 11111111 11111110
	//5.移动后的补码: 11111111 11111111 11111111 11111110
	//6.移动后的反码: 11111111 11111111 11111111 11111101
	//7.移动后的原码: 10000000 00000000 00000000 00000010
	//8.该二进制原码的值：-2
	printf("%d\n", c);//c=-1
	printf("%d\n", d);//d=-2

	int e = 1;
	int f = e >> 1;
	//1.写出1的原码：00000000 00000000 00000000 00000001
	//2.写出1的补码：00000000 00000000 00000000 00000001
	//3.向右移一位： 00000000 00000000 00000000 00000000
	//4.移动后的补码:00000000 00000000 00000000 00000000
	//5.移动后的原码:00000000 00000000 00000000 00000000
	//6.该二进制原码的值：0
	printf("%d\n", e);//e=1
	printf("%d\n", f);//f=0

	int g = -1;
	int h = g >> 1;
	//1.写出-1的原码：10000000 00000000 00000000 00000001
	//2.写出-1的反码：11111111 11111111 11111111 11111110
	//3.写出-1的补码：11111111 11111111 11111111 11111111
	//4.向右移一位：  11111111 11111111 11111111 11111111
	//5.移动后的补码: 11111111 11111111 11111111 11111111
	//6.移动后的反码: 11111111 11111111 11111111 11111110
	//7.移动后的原码: 10000000 00000000 00000000 00000001
	//8.该二进制原码的值：-1
	printf("%d\n", g);//c=-1
	printf("%d\n", h);//d=-1

	return 0;
}*/
//位操作符，仅用于整型
//int main(){
//------------------------------------------------------------------------
	//1.位操作符
	//&--（二进制）按位与
	//|--（二进制）按位或
	//^--（二进制）按位异或

	//int a = 1;
	//int b = 2;
	//int c = a & b;
	//int d = a | b;
	//int e = a ^ b;
	//思路
	//一.写出两个数的补码用于计算，正数三码合一，负数要先写反码，再写补码
	//1的补码：00000000 00000000 00000000 00000001
	//2的补码：00000000 00000000 00000000 00000010
	//二.按位与：将两个补码按位进行比较，对应的二进制位,只要有0则为0，都为1则为1.
	//&的结果（补码）：00000000 00000000 00000000 00000000
	//&的结果（原码）：00000000 00000000 00000000 00000000
	// 结果：0
	//结果使用%d来打印，%d则意味着打印的是一个有符号的整数
	//printf("c=%d\n", c);

	//思路
	//一.写出两个数的补码用于计算，正数三码合一，负数要先写反码，再写补码
	//1的补码：00000000 00000000 00000000 00000001
	//2的补码：00000000 00000000 00000000 00000010
	//二.按位或：将两个补码按位进行比较，对应的二进制位,只要有1则为1，都为0则为0.
	//|的结果（补码）：00000000 00000000 00000000 00000011
	//|的结果（原码）：00000000 00000000 00000000 00000011
	// 结果：3

	//printf("d=%d\n", d);
	//思路
	//一.写出两个数的补码用于计算，正数三码合一，负数要先写反码，再写补码
	//1的补码：00000000 00000000 00000000 00000001
	//2的补码：00000000 00000000 00000000 00000010
	//二.按位异或：将两个补码按位进行比较，对应的二进制位,相同则为0，不同则为1.
	//^的结果（补码）：00000000 00000000 00000000 00000011
	//^的结果（原码）：00000000 00000000 00000000 00000011
	//结果：3
	//printf("e=%d\n", e);
//---------------------------------------------------------------------------------
//案例：不创建临时变量，实现两个数的交换
	//int num1 = -10;
	//int num2 = -20;
//第一种方法：存在限制，易出现数据溢出，就无法正常输出
	/*printf("交换前：num1=%d,num2=%d\n", num1, num2);
	num1 = num1 + num2;
	num2 = num1 - num2;
	num1 = num1 - num2;
	printf("交换后：num1=%d,num2=%d\n", num1, num2);
	printf("-----------------------------------------------------------------\n");*/
//第二种方法：按位异或,支持交换律 (a^a = 0; 0^a = a;），但仅用于整型
	/*printf("交换前：num1=%d,num2=%d\n", num1, num2);
	num1 = num1 ^ num2;//num1 = 10 ^ 20
	num2 = num1 ^ num2;//num2 = 10 ^ 20 ^ 20 = 10;
	num1 = num1 ^ num2;//num1 = 10 ^ 20 ^ 10 = 20;
	printf("交换后：num1=%d,num2=%d\n", num1, num2);*/
//---------------------------------------------------------
//求一个整数存储在内存中的二进制中1的个数
	//求补码二进制中1的个数
	/*int num = 0;
	int count = 0;
	printf("请输入任意整数：");
	scanf("%d", &num);
	
	//00000000 00000000 00000000 00001010  =10
	//00000000 00000000 00000000 00000001  =1
	//00000000 00000000 00000000 00000001  =1
	while (num)
	{
		if ((num&1) == 1)
		{
			count++;	
		}
			num = num >> 1;
	}
	printf("该数在内存中的二进制1的个数：%d\n", count);*/
//}
//------------------------------------------------------------------------------
//单目操作符
	//!:逻辑取反，
	// -/+ 负值，正值
	//&:取地址
	//sizeof：操作数的类型长度
	// 计算的是变量所占内存的大小，单位是字节
	// 计算类型所创建的变量占据空间的大小
	// ~:对一个数二进制位取反，取反后的是补码，结果要转成原码
	//前++：先自增，后赋值  b = ++a => a = a+1; b = a;	先自增，再使用
	//后++：先赋值，在自增  b = a++ => b = a; a = a+1;	先使用，再自增
	//--同理
	//* ：间接访问操作符（解引用操作符，用于指针变量）
	//(类型)：强制转换类型
	
//--------------------------------------------------------------------------------
//逻辑操作符
//只关注真假,两边若有一个为0，则结果为假。C语言中，0为假，非零为真。
//&&：逻辑与（并且），只要有一个为假，则结果为假。两个都为真，结果为真
//||：逻辑或（或者），只要有一个为真，则结果为真。两个都为假，结果为假
//逻辑操作符中真指的是1；
/*int main()
{
	int a = 1;
	int b = 2;
	int c = 0;

	int c1 = a & b;
	printf("%d\n", c1); //c1= 0;

	int c2 = a && b;
	printf("%d\n", c2); //c2 = 1;

	int c3 = a && c;
	printf("%d\n", c3); //c3 = 0;

	int d1 = a | b;
	printf("%d\n", d1); //c1= 3;

	int d2 = a || b;
	printf("%d\n", d2); //d1= 1;

	int d3 = a || c;
	printf("%d\n", c3); //d3 = 0;

	
}*/

//条件操作符（三目运算符）
//条件？结果一:结果二
//条件为真返回结果一，假返回结果2.
/*int main()
{
	int a = 2;
	int b = 3;

	//求两个数的最大值
	int max = a > b ? a : b;
	printf("max = %d\n", max);
}*/

//逗号表达式
//用逗号隔开的多个表达式
//从左到右依次执行
//整个表达式的结果是最后一个表达式的结果
/*int main()
{
	int a = 2;
	int b = 3;
	int c = (a > b, a = b + 1, a, b = a + 1, b > 0);
	printf("c = %d\n",c);
	
}*/

//下标引用操作符、函数调用和结构成员
//1.[]：下标引用操作符
//操作数：数组名 + 索引值
/*int main()
{
	int arr[10] = {0};
		arr[7] = 10;
		//arr[7] --> *(arr+7) --> *(7+arr)--> 7[arr]
		//arr是数组首元素的地址
		//arr + 7 就是跳过7个元素，指向了第8个元素
		//*(arr+7) 就是第8个元素
		7[arr] = 12;
		//二者效果等同
	return 0;
}*/
//2.()：函数调用操纵符
//接受一个或者多个操作数，第一个操作数是函数名，剩余的操作数就是传给函数的参数

//3.结构成员操作符
//访问一个结构的成员
//.：结构体.成员名
//->：结构体指针->成员名
/*
struct Stu
	//结构体的内容
{
	char name[20];
	int age;
	double score;
};

void set_stu(struct Stu *ps) {
	//strcpy((*ps).name, "zhangsan");
	//(*ps).age = 20;
	//(*ps).score = 100.0;
	strcpy(ps->name, "zhangsan");
	ps -> age;
	ps -> score;

}
void print_stu(struct Stu *ps) {
	printf("%s,%d,%lf\n",ps -> name,ps->age,ps->score );
}
int main()
{
	struct Stu s = { 0 };
	set_stu(&s);
	print_stu(&s);
	return 0;
}
*/


//知识点
//C语言的整型算数运算总是至少以缺省整型类型的精度来进行的
//为了获取这个精度，表达式中的字符和短整型操作数在使用之前被转换成普通整型，这种转换称为整型提升
//怎么进行整型提升？
//整型提升是按照变量的数据类型的符号位来提升的，无符号直接补0
//为什么要整型提升？
//因为表达式的运算是在CPU的相应运算器件内执行，
//CPU内整型运算器的操作数长度的字节长度一般是int的字节长度，
//同时也是CPU的通用寄存器长度
//通常情况下，在对int类型的数值作运算时，CPU的运算速度是最快的。
//在x86上，32位算术运算的速度比16位算术运算的速度快一倍。
//C语言是一个注重 效率的语言，所以它会作整型提升，使得程序的运行速度尽可能地快。
//因此，你必须记住整型提升规则，以免发生一些整型溢出的问题。
/*
int main()
{
	char c = -1;//-1是整数，占32个比特位
	//-1的原码：10000000 00000000 00000000 00000001
	//-1的反码：11111111 11111111 11111111 11111110
	//-1的补码：11111111 11111111 11111111 11111111
	//因为c是char ，只占8个bit，所以只存放第一个八位 c-> 11111111
	//如何整型提升？因为char是有符号的char，所以把做高位当做符号位，因此在高位补充符号位1
	// 提升结果为：11111111 11111111 11111111 11111111
	char a = 5;
	//5的原码：10000000 00000000 00000000 00000101
	//5的补码：10000000 00000000 00000000 00000101
	//截断存放在a-> 0000 0101
	
	char b = 126;
	//126的原码：00000000 00000000 00000000 01111110
	//126的补码：10000000 00000000 00000000 01111110
	//截断存放在b-> 01111110
	//整型提升：

	char c = a + b;
	printf("%d\n",c);
	//c=?
	//a-> 0000 0101
	//整型提升： 00000000 00000000 00000000 00000101
	//b-> 0111 1110
	//整型提升： 00000000 00000000 00000000 01111110
	// 
	//提升相加： 00000000 00000000 00000000 10000011
	// c也是char，只占8个bit，所以c-> 1000 0011
	// 最后打印c，打印的是整数，所以还要进行整型提升
	// 提升的补码：11111111 11111111 11111111 10000011
	// 提升的反码：11111111 11111111 11111111 10000010
	// 提升的原码：10000000 00000000 00000000 01111101
	// 所以 c= - 125

	//char在底层存放的是ASCII，ASCII也是整型，整型在内存中存放的都是补码，用计算的也是补码
	//输出展示的是原码

}
*/

//操作符的属性
//复杂表达式的求值有三个影响的因素
//1.操作符的优先级
//2.操作符的结合性
//3.是否控制求值顺序


