#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
//类型的意义
//使用这个类型开辟的空间的大小，大小决定了使用范围
//决定了如何看待内存空间的视角
//类型的分类
//整型家族：char /short /int /long /long long
//浮点型家族：float/double，只要是表示小数就可以用浮点型
//				float精度低，存储的数值范围小；double精度高，存储的数值范围大
//构造类型：数组类型、结构体类型struct、枚举类型enum、联合类型union
//指针类型：int*,char*,float*,void*
//空类型

//整型在内存中的存储
// 
//数值有不同的表现形式：2/8/10/16进制
// 
//整数的二进制有三种表现形式：原码、反码、补码
// 规则：1.正整数的原码补码反码相同，正整数，三码合一。
//		 2.二进制的最高位是符号位，0表示正数，1表示负数
//		 3.负数的反码 = 它的原码符号位不变，其他位取反（0->1,1->0）
//		 4.负数的补码 = 它的反码 + 1 ; 负数的反码 = 负数的补码 -1;
//		技巧：负数的原码 = 负数的补码取反 + 1
//		 5.0的反码补码都是0
//		 6.在计算机运算的时候，都是以补码的方式运算
//	理由：使用补码，可以将符号位和数值域统一处理
//		 7.我们得到运算结果的时候，要看它的原码
//		 8.整数在内存中，存储的是补码

//int main()
//{
//	int a = 20;
//	//20
//	//20的原码：00000000 00000000 00000000 00010100
//	// 由于冗长，将每4位用16进制表示
//	// 0x 00 00 00 14
//	//20的反码：00000000 00000000 00000000 00010100
//	// 0x 00 00 00 14
//	//20的补码：00000000 00000000 00000000 00010100
//	// 0x 00 00 00 14
//	int b = -10;
//	//-10的原码：10000000 00000000 00000000 00001010
//	// 0x 80 00 00 0a
//	//-10的反码：11111111 11111111 11111111 11110101
//	// 0x ff ff ff f5
//	//-10的补码：11111111 11111111 11111111 11110110
//	// 0x ff ff ff f6
//	return 0;
//}
// 
// 为什么在内存中的会反过来显示？由于地址是由低到高变化的，数据存储进内存有不同的方式
// 大端【字节序】存储：把一个数据的把低位【字节序】的内容放在高地址处，高位字节序的内容存放在低地址处
// 小端【字节序】存储：把一个数据的把低位【字节序】的内容放在低地址处，高位字节序的内容存放在高地址处
//设计代码判断当前的机器的字节序

int main()
{
	int a = 1;
	//00000000 00000000 00000000 00000001
	//0x 00 00 00 01
	//char* p = (char*)&a;
	if (*(char*)&a == 1)
	{
		printf("小端\n");
	}
	else
	{
		printf("大端\n");
	}


}